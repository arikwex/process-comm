// Generated by CoffeeScript 1.9.3
(function() {
  var EventEmitter, emitLines, externalDefer, makePackage, openPackage, processDefers, processEvents, q, spawn;

  q = require('q');

  spawn = require('child_process').spawn;

  EventEmitter = require('events').EventEmitter;

  processEvents = new EventEmitter();

  processDefers = {};

  exports.spawn = function(command, args, options) {
    var connectionOpen, worker, workerDeferCode, workerDefers, workerEvents, workerSpawn;
    connectionOpen = true;
    workerSpawn = spawn(command, args, options);
    workerEvents = new EventEmitter();
    workerDefers = {};
    workerDeferCode = 0;
    emitLines(workerSpawn.stdout);
    emitLines(workerSpawn.stderr);
    workerSpawn.stdout.on('line', function(buf) {
      var pkg;
      pkg = openPackage(String(buf));
      if (pkg != null) {
        workerEvents.emit(pkg.type, pkg.params, pkg.code);
      }
    });
    workerSpawn.stderr.on('line', function(buf) {
      if (String(buf).length > 0) {
        workerEvents.emit('error', String(buf));
      }
    });
    workerSpawn.stdout.on('close', function() {
      var code, defer;
      workerEvents.emit('close');
      for (code in workerDefers) {
        defer = workerDefers[code];
        defer.reject('close');
      }
      connectionOpen = false;
      return workerEvents.removeAllListeners();
    });
    worker = {
      isAlive: function() {
        return connectionOpen;
      },
      free: function() {
        workerSpawn.kill('SIGTERM');
        connectionOpen = false;
      },
      write: function(msg) {
        worker.emit('data', msg);
      },
      on: function(type, callback) {
        if (connectionOpen) {
          workerEvents.on(type, callback);
        }
      },
      emit: function(type, msg) {
        var pkg;
        if (connectionOpen) {
          pkg = makePackage(type, msg);
          workerSpawn.stdin.write(pkg + '\n');
        }
      },
      promise: function(cmd, params) {
        var d, notifyCallback, p;
        d = q.defer();
        if (connectionOpen) {
          workerDefers[workerDeferCode] = d;
          worker.emit('defer', {
            code: workerDeferCode,
            cmd: cmd,
            params: params
          });
          workerDeferCode++;
        } else {
          d.reject('spawn closed');
        }
        p = {};
        notifyCallback = function() {};
        p.notify = function(callback) {
          notifyCallback = callback;
          return p;
        };
        p.then = function(callback) {
          d.promise.then(callback);
          return p;
        };
        p["catch"] = function(callback) {
          d.promise["catch"](callback);
          return p;
        };
        p.always = function(callback) {
          d.promise.then(callback);
          d.promise["catch"](callback);
          return p;
        };
        d.promise.then(null, null, function(msg) {
          return notifyCallback(msg);
        });
        return p;
      }
    };
    worker.on('promise', function(msg) {
      var cmd, code;
      code = msg.code;
      cmd = msg.cmd;
      if (workerDefers[code] != null) {
        if (cmd === 'resolve') {
          workerDefers[code].resolve(msg.params);
          delete workerDefers[code];
        } else if (cmd === 'reject') {
          workerDefers[code].reject(msg.params);
          delete workerDefers[code];
        } else if (cmd === 'notify') {
          workerDefers[code].notify(msg.params);
        } else {
          worker.emit('error', "Invalid promise command '" + cmd + "' for code " + code);
        }
      } else {
        worker.emit('error', "Promise code " + code + " is not identified");
      }
    });
    return worker;
  };

  exports.write = function(msg) {
    exports.emit('data', msg);
  };

  exports.on = function(type, callback) {
    processEvents.on(type, callback);
  };

  exports.emit = function(type, payload) {
    var pkg;
    pkg = makePackage(type, payload);
    process.stdout.write(pkg + '\n');
  };

  exports.defer = function(cmd, callback) {
    processDefers[cmd] = callback;
  };

  emitLines = function(stream) {
    var backlog;
    backlog = '';
    stream.on('data', function(data) {
      var n, results;
      backlog += data;
      n = backlog.indexOf('\n');
      results = [];
      while (~n) {
        stream.emit('line', backlog.substring(0, n));
        backlog = backlog.substring(n + 1);
        results.push(n = backlog.indexOf('\n'));
      }
      return results;
    });
    stream.on('end', function() {
      if (backlog) {
        return stream.emit('line', backlog);
      }
    });
  };

  externalDefer = function(code) {
    var done, transmit;
    done = false;
    transmit = function(type, canClose) {
      return function(msg) {
        if (!done) {
          exports.emit('promise', {
            code: code,
            cmd: type,
            params: msg
          });
          done = canClose;
        }
      };
    };
    return {
      resolve: transmit('resolve', true),
      reject: transmit('reject', true),
      notify: transmit('notify', false)
    };
  };

  makePackage = function(type, msg) {
    var pkg;
    if (msg == null) {
      msg = '';
    }
    pkg = {
      type: type,
      params: msg
    };
    return JSON.stringify(pkg);
  };

  openPackage = function(json) {
    var e, pkg;
    try {
      pkg = JSON.parse(json);
      if ((pkg.type == null) || (pkg.params == null)) {
        return null;
      }
      return pkg;
    } catch (_error) {
      e = _error;
      return null;
    }
  };

  emitLines(process.stdin);

  process.stdin.on('line', function(buf) {
    var pkg;
    pkg = openPackage(String(buf));
    if (pkg != null) {
      processEvents.emit(pkg.type, pkg.params, pkg.code);
    }
  });

  exports.on('defer', function(msg) {
    var cmd, code, ed;
    code = msg.code;
    cmd = msg.cmd;
    if (processDefers[cmd] != null) {
      ed = externalDefer(code);
      return processDefers[cmd](ed, msg.params);
    } else {
      return exports.emit('promise', {
        code: code,
        cmd: 'reject',
        params: "No deferred listener '" + cmd + "' configured on remote process"
      });
    }
  });

}).call(this);
